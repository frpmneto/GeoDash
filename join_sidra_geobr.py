# -*- coding: utf-8 -*-
"""Join-Sidra-GeoBR.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fWjA8DU4biygpGo8E_f1nPdSOO7oO6cf

# 1. Introdu√ß√£o

Este notebook tem como objetivo **coletar e tratar dados do SIDRA/IBGE utilizando a biblioteca `sidraPy`**, facilitando a an√°lise estat√≠stica de indicadores brasileiros.

## ‚ÑπÔ∏è O que √© o SIDRA?

O **SIDRA (Sistema IBGE de Recupera√ß√£o Autom√°tica)** √© uma plataforma do IBGE que disponibiliza dados estat√≠sticos sobre diversos temas do Brasil, como demografia, economia e agricultura. Esses dados podem ser acessados via API para an√°lises automatizadas.

## üêç Sobre a biblioteca `sidraPy`

A **`sidraPy`** √© uma biblioteca Python desenvolvida pela comunidade que simplifica o processo de consulta √† API do SIDRA. Ela permite fazer requisi√ß√µes diretas aos dados do IBGE e obt√™-los em formatos prontos para an√°lise (como DataFrames do pandas).

**Principais benef√≠cios:**
- Automatiza o download de dados diretamente da base do IBGE.
- Transforma as informa√ß√µes em estruturas Python (dicion√°rios, DataFrames).
- Permite personalizar filtros como tabela, per√≠odo, localidade e vari√°veis.

## ‚öôÔ∏è Personalizando consultas

A principal fun√ß√£o da biblioteca √© o `get_table()`, que permite definir de forma flex√≠vel:
- **Tabela**: o c√≥digo da tabela SIDRA a ser consultada.
- **Per√≠odo**: anos ou meses espec√≠ficos dos dados.
- **Localidade**: n√≠vel territorial (Brasil, regi√µes, estados, munic√≠pios).
- **Vari√°veis** e classifica√ß√µes espec√≠ficas.

Com isso, √© poss√≠vel obter exatamente o recorte estat√≠stico desejado para sua an√°lise.

# 2. Instala√ß√£o e importa√ß√£o das bibliotecas
"""
import sidrapy
import pandas as pd
import plotly as plt
import geobr as geo
import geopandas as gpd
import plotly.express as px
import warnings
warnings.filterwarnings("ignore")

"""# 3. Par√¢metros da coleta
- Tabela: 6417 - Pessoas de 10 anos ou mais de idade, por cor ou ra√ßa, segundo o sexo e a religi√£o
- N√≠vel territorial: Unidade da Federa√ß√£o
- Per√≠odo: 2022
- Vari√°veis: 140
- Classificadores: 86(Cor/ra√ßa), 2(Sexo) e 133(Religi√£o)

Exemplos de tabelas:
*   10198 - 	Pessoas de 15 anos ou mais de idade por religi√£o, segundo os grupos de idade e alfabetiza√ß√£o
*   9542 - Pessoas de 15 anos ou mais de idade, total e as alfabetizadas, por sexo, cor ou ra√ßa e grupos de idade
*   6417 - Pessoas de 10 anos ou mais de idade, por cor ou ra√ßa, segundo o sexo e a religi√£o
*   10147	- Popula√ß√£o residente, total e diagnosticada com autismo, por cor ou ra√ßa
*   9591 - N√∫mero de microempreendedores individuais (MEIs) e m√©dia de idade, por sexo, faixas de idade, nacionalidade/pa√≠s de origem, cor ou ra√ßa, etc
"""

df = sidrapy.get_table(
    table_code='6417',
    territorial_level='3',    # Unidade da Federa√ß√£o (UF)
    ibge_territorial_code='all',
    period='2022',
    variable='140',       # Pessoas de 10 anos ou mais de idade (Pessoas)
    format='pandas',
    classifications={"133": "95263,95277,2826,2827,95274,95275,2836,12890,2837", "2": "4,5", "86": "2776,2777,2778,2779,2780"},
)

df.head()

state = geo.read_state(code_state="all", year=2020)
state.head()

df.shape

state.shape

"""# 4. Tratamento dos dados"""

# Header da tabela est√° na linha 0
df.iloc[:1]

# Adicionando a linha 0 como nome das colunas
df.columns = df.iloc[0]
df = df[1:].reset_index(drop=True)
df.head(3)

# Lista das colunas a serem removidas
colunas_a_remover = [
    'Unidade de Medida (C√≥digo)',
    'Unidade de Medida',
    'Ano (C√≥digo)',
    'Vari√°vel (C√≥digo)',
    'Religi√£o (C√≥digo)',
    'Sexo (C√≥digo)',
    'Cor ou ra√ßa (C√≥digo)'
]

# Remove as colunas do DataFrame
df = df.drop(columns=colunas_a_remover, errors='ignore')
df.head()

# Removendo valores inexistentes
df_filtered = df[df['Valor'] != '-']

# Convertendo a coluna de Valor para int
df_filtered['Valor'] = df_filtered['Valor'].astype(int)

# Reduzindo o nome da religi√£o Cat√≥lica
df_filtered['Religi√£o'] = df_filtered['Religi√£o'].replace('Cat√≥lica Apost√≥lica Romana', 'Cat√≥lica')

# Deixando o mesmo nome da outra coluna
df_filtered = df_filtered.rename(columns={'Unidade da Federa√ß√£o (C√≥digo)': 'code_state'})

# Convertendo o valor float para object
state['code_state'] = state['code_state'].astype(int).astype(str)

merged_df = pd.merge(state, df_filtered, on='code_state', how='inner')
merged_df.head()

merged_df.columns

merged_df.info()
# merged_df['Religi√£o'] = merged_df['Religi√£o'].replace(['sem declaracao', 'nao sabe'], 'outras religiosidades')
merged_df['Religi√£o'] = merged_df['Religi√£o'].replace(['Sem declara√ß√£o', 'N√£o sabe'], 'Outras religiosidades')
merged_df.to_csv('merged_df.csv', index=False)

"""# 5. Gr√°ficos

## Estado x Religi√£o
"""

def escala_formato(value):
    if value >= 1_000_000:
        return f'{value / 1_000_000:.2f} M'
    elif value >= 1000:
        return f'{value / 1000:.0f} K'
    else:
        return f'{value:.0f}'

# Filtrando o DataFrame para o estado selecionado
state_name = "Pernambuco"
df_state = merged_df[merged_df['Unidade da Federa√ß√£o'] == state_name].copy()

# Agrupando por Religi√£o pela soma
religiao_group = df_state.groupby('Religi√£o')['Valor'].sum().reset_index()

# Criando coluna formatada com escala personalizada
religiao_group['Valor_formatado'] = religiao_group['Valor'].apply(escala_formato)

# Convertendo Valor para milh√µes para manter o eixo
religiao_group['Valor_M'] = religiao_group['Valor'] / 1_000_000

# Ordenando
religiao_group.sort_values(by='Valor_M', ascending=False, inplace=True)

# Plotando o gr√°fico
fig1 = px.bar(
    religiao_group,
    x='Religi√£o',
    y='Valor_M',
    title=f'Distribui√ß√£o da Popula√ß√£o por Religi√£o em {state_name}',
    text='Valor_formatado',
    color='Religi√£o',
    color_discrete_sequence=px.colors.qualitative.Set2
)

fig1.update_layout(
    xaxis_tickangle=-45,
    xaxis_title=None,
    yaxis_title=None,
    yaxis=dict(showticklabels=False, showgrid=True, zeroline=False),
    plot_bgcolor='white'
)
fig1.update_traces(textposition='outside')

fig1.show()

"""## Estado x Sexo"""

# Filtrando o DataFrame para o estado selecionado
state_name = "S√£o Paulo"
df_state = merged_df[merged_df['Unidade da Federa√ß√£o'] == state_name].copy()

# Agrupando por Sexo pela soma do Valor
sexo_group = df_state.groupby('Sexo')['Valor'].sum().reset_index()

# Plotando a figura
fig2 = px.pie(
    sexo_group,
    names='Sexo',
    values='Valor',
    title= f'% da Popula√ß√£o por Sexo em {state_name}',
    color_discrete_sequence=px.colors.qualitative.Set3
)

# Elementos de design do gr√°fico
fig2.update_traces(textinfo='percent+label', pull=[0.05, 0])
fig2.update_layout(
    margin=dict(l=20, r=20, t=50, b=20),
    height=400,
    width=600
)
fig2.show()

"""# Cor/Ra√ßa x Estado"""

# Filtrando o DataFrame para o estado selecionado
state_name = "Bahia"
df_state = merged_df[merged_df['Unidade da Federa√ß√£o'] == state_name].copy()

# Agrupando por Cor/Ra√ßa
cor_group = df_state.groupby('Cor ou ra√ßa')['Valor'].sum().reset_index()

# Criando coluna formatada
cor_group['Valor_formatado'] = cor_group['Valor'].apply(escala_formato)

# Convertendo Valor para milh√µes para manter o eixo fixo em M
cor_group['Valor_M'] = cor_group['Valor'] / 1_000_000

# Ordenando
cor_group.sort_values(by='Valor_M', ascending=False, inplace=True)

# Plotando o gr√°fico
fig3 = px.bar(
    cor_group,
    x='Cor ou ra√ßa',
    y='Valor_M',
    title=f'Distribui√ß√£o da Popula√ß√£o por Cor/Ra√ßa em {state_name}',
    text='Valor_formatado',
    color='Cor ou ra√ßa',
    color_discrete_sequence=px.colors.qualitative.Pastel2
)

fig3.update_layout(
    xaxis_tickangle=-45,
    xaxis_title=None,
    yaxis_title=None,
    yaxis=dict(showticklabels=False, showgrid=True, zeroline=False),
    plot_bgcolor='white'
)
fig3.update_traces(textposition='outside')
fig3.show()


"""# Sexo x Ra√ßa por Estado"""
# Filtrando o DataFrame para o estado selecionado
state_name = "Pernambuco"
df_state = merged_df[merged_df['Unidade da Federa√ß√£o'] == state_name].copy()

df_sexo_cor = df_state.groupby(['Sexo', 'Cor ou ra√ßa'])['Valor'].sum().reset_index()

fig4 = px.bar(df_sexo_cor,
             x='Sexo',
             y='Valor',
             color='Cor ou ra√ßa',
             title=f'Distribui√ß√£o da Popula√ß√£o por Cor/Ra√ßa e Sexo - {state_name}',
             labels={'Valor': 'Popula√ß√£o'},
             color_discrete_sequence=px.colors.qualitative.Vivid,
             text='Valor')

fig4.update_layout(barmode='stack', 
                    xaxis_tickangle=-45,
                    margin=dict(l=20, r=20, t=50, b=20),
                    height=500,
                    width=600)
fig4.update_traces(texttemplate='%{text:.2s}', textposition='outside')
fig4.show()